#!/usr/bin/env python

# # Correlation analysis

# In[1]:


import pathlib
import sys
import warnings

import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

sys.path.append("../../../")
from utils import data_utils

# ignore all warnings
warnings.filterwarnings("ignore")

# setting seed for reproducibility
np.random.seed(0)


# Helper functions

# In[2]:


def update_dmso_pathway_label(treatment: str, pathway: str) -> str:
    """
    Update the pathway label for wells treated with DMSO.

    Wells treated with DMSO do not have a specific pathway label. This function assigns
    a pathway label based on the type of DMSO treatment: "DMSO-positive" or "DMSO-negative".
    For other treatments, the original pathway label is retained.

    Parameters
    ----------
    treatment : str
        The treatment type, e.g., "DMSO-positive" or "DMSO-negative".
    pathway : str
        The current pathway label.

    Returns
    -------
    str
        The updated pathway label. If the treatment is "DMSO-positive" or "DMSO-negative",
        the pathway label is updated to match the treatment type. Otherwise, the original
        pathway label is returned unchanged.
    """
    if treatment == "DMSO-positive":
        return "DMSO-positive"
    elif treatment == "DMSO-negative":
        return "DMSO-negative"
    else:
        return pathway


# Loading the data

# In[3]:


data_path = pathlib.Path("../UMAP-aggregated-fs-profiles/results/concat_data/batch_1_concat_agg_fs.csv")

# setting output path
output_path = pathlib.Path("results/")
output_path.mkdir(parents=True, exist_ok=True)


# In[4]:


# load the data
concat_profile_df = pd.read_csv(data_path)

# update the Pathway label for wells treated with DMSO
concat_profile_df["Metadata_Pathway"] = concat_profile_df.apply(
	lambda row: update_dmso_pathway_label(row["Metadata_treatment"], row["Metadata_Pathway"]), axis=1
)

# concat_profile_df["Metadata_Pathway"].replace("nan", "No Pathway", inplace=True)


# split the data into metadata and features
meta_cols, feat_cols = data_utils.split_meta_and_features(concat_profile_df)

concat_profile_df.head()


# ## Calculating correlation of each samples
#
# In this section fo the notebook, we build on our Pearson correlation analysis by visualizing the data with a seaborn clustermap. With each treatment linked to a specific pathway target, the clustergram not only groups samples based on morphological similarity but also allows us to observe whether treatments targeting the same pathway exhibit similar phenotypic profiles. This integrative approach provides insights into how specific pathway interventions drive morphological changes, thereby enhancing our biological interpretation of the treatment effects.

# In[5]:


# creating a dataframe with only the pathway and morphological features
pathway_df = concat_profile_df[["Metadata_treatment", "Metadata_Pathway"] + feat_cols]

# Replace invalid or missing values in the "Metadata_Pathway" column using apply()
# pathway_df["Metadata_Pathway"] = pathway_df["Metadata_Pathway"].apply(
#     lambda x: "No Pathway" if pd.isna(x) or x in ["NaN", "nan"] else x
# )

# creating a dataframe with only morphological features
morph_df = pathway_df[feat_cols].copy()

# Calculate the pearson correlation between treated samples (well-level profiles)
sample_corr_matrix = morph_df.T.corr(method="pearson")

sample_corr_matrix.head()


# With the correlation matrix generated by calculating the correlation by each sample, then we create a clustergram where the axis represents the pathway of each treament, and the color gradient represents the correlation between samples.With the correlation matrix computed from each sampleâ€™s morphological profile, we generate a clustergram using seaborn. In this visualization, the axes are annotated with the pathway targets associated with each treatment, while the color gradient reflects the strength of the correlation between samples, enabling us to identify clusters of treatments with similar phenotypic responses.

# In[6]:


# plot the correlation matrix
plt.figure(figsize=(12, 12))

# create a color bar for the unique pathways
unique_pathways = pathway_df["Metadata_Pathway"].unique()
pathway_colors = sns.color_palette("tab20", len(unique_pathways))
pathway_color_dict = dict(zip(unique_pathways, pathway_colors))


# create a color map for the treatments
pathway_color_map = pathway_df["Metadata_Pathway"].map(pathway_color_dict)

# using seaborn, plot a clustermap
sample_corr_clustermap = sns.clustermap(
    sample_corr_matrix,
    row_colors=pathway_color_map,
    col_colors=pathway_color_map,
    cmap="coolwarm",
    figsize=(12, 12),
    xticklabels=1,
    yticklabels=1,
    cbar_pos=(0.90, 0.50, 0.02, 0.2)
)

# adding title to the clustermap figure
sample_corr_clustermap.fig.suptitle("Correaltion Clustermap of Treated Samples", fontsize=16, y=1.01)

# remove x and y ticks and labels
sample_corr_clustermap.ax_heatmap.set_xticklabels([])
sample_corr_clustermap.ax_heatmap.set_yticklabels([])
sample_corr_clustermap.ax_heatmap.set_xticks([])
sample_corr_clustermap.ax_heatmap.set_yticks([])

# adding the Pathway legend to the cluster map
handles = [mpatches.Patch(color=color, label=pathway) for pathway, color in pathway_color_dict.items()]
sample_corr_clustermap.fig.legend(handles=handles, title="Pathway", loc="upper right", bbox_to_anchor=(1.09, 0.49))

# now taking the colobar legend and adding a title
cbar = sample_corr_clustermap.ax_heatmap.collections[0].colorbar
cbar.ax.set_title("Correlation", fontsize=11, x=0.5, y=1.02)

# save the figure
output_file = output_path / "sample_corr_clustermap.png"
sample_corr_clustermap.savefig(output_file, dpi=500, bbox_inches="tight")

sample_corr_clustermap


# ## Correlation matrix sorted by treatment name

# In[7]:


# calculate the correlation
concat_profile_df = concat_profile_df.sort_values(by=["Metadata_treatment"])
sorted_morph_df = concat_profile_df[feat_cols].copy()
sorted_df_measurement_labels = [colname.split("_")[1] for colname in sorted_morph_df.columns]

# calculate the correlation matrix for the sorted dataframe
sorted_treatment_corr_matrix = sorted_morph_df.corr(method="pearson")


# In[8]:


# setting the figure size
plt.figure(figsize=(12, 12))

# creating a color bar for the unique measurement labels
unique_measurements = list(set(sorted_df_measurement_labels))
sorted_measurement_colors = sns.color_palette("tab10", len(unique_measurements))
sorted_measurement_color_dict = dict(zip(unique_measurements, sorted_measurement_colors))


# create a color map for the treatments
measurement_color_map = pd.Series(
    sorted_df_measurement_labels,
    index=sorted_treatment_corr_matrix.index
).map(sorted_measurement_color_dict)


# Plotting the sorted correlation matrix
sorted_treatment_corr_clustermap = sns.clustermap(
    sorted_treatment_corr_matrix,
    row_colors=measurement_color_map,
    col_colors=measurement_color_map,
    cmap="coolwarm",
    figsize=(12, 12),
    xticklabels=1,
    yticklabels=1,
    col_cluster=False,
    row_cluster=False,
)

# removing x and y ticks and labels
sorted_treatment_corr_clustermap.ax_heatmap.set_xticklabels([])
sorted_treatment_corr_clustermap.ax_heatmap.set_yticklabels([])
sorted_treatment_corr_clustermap.ax_heatmap.set_xticks([])
sorted_treatment_corr_clustermap.ax_heatmap.set_yticks([])

# removing the dendogram padding (the padding is still there, but not visible)
sorted_treatment_corr_clustermap.ax_row_dendrogram.set_visible(False)
sorted_treatment_corr_clustermap.ax_col_dendrogram.set_visible(False)

# adding title to the clustermap figure
sorted_treatment_corr_clustermap.fig.suptitle("Correlation Clustermap of Sorted Measurements", fontsize=16, y=0.9)


# adding the Measurement legend to the cluster map
handles = [mpatches.Patch(color=color, label=measurement) for measurement, color in sorted_measurement_color_dict.items()]
sorted_treatment_corr_clustermap.fig.legend(handles=handles, title="Measurement", loc="upper right", bbox_to_anchor=(.88, .7))


# now taking the colobar legend and adding a title
cbar = sorted_treatment_corr_clustermap.ax_heatmap.collections[0].colorbar
cbar.ax.set_title("Correlation", fontsize=11, x=0.5, y=1.02)
cbar.ax.set_position([0.66, 0.39, 0.02, 0.4])

# save the correlation heatmap
plt.savefig(output_path / "correlation_morph_sorted_treatments.png", dpi=500)

# display the sorted treatment correlation clustermap
sorted_treatment_corr_clustermap


# ## Correlation cluster gram of morphological features

# In[9]:


morph_df = concat_profile_df[feat_cols].copy()
morph_labels = [colname.split("_")[0] for colname in feat_cols]
measurement_labels = [colname.split("_")[1] for colname in feat_cols]
corr_morph_df = morph_df.corr(method="pearson")


# In[10]:


# setting figure size
plt.figure(figsize=(12, 12))

# Create the color maps (already defined)
unique_morph_labels = list(set(morph_labels))
morph_colors = sns.color_palette("tab10", len(unique_morph_labels))
morph_color_dict = dict(zip(unique_morph_labels, morph_colors))

unique_measurement_labels = list(set(measurement_labels))
measurement_colors = sns.color_palette("tab20", len(unique_measurement_labels))
measurement_color_dict = dict(zip(unique_measurement_labels, measurement_colors))

# create a color map for the morphological features and measurement types
morph_color_map = pd.Series(morph_labels, index=feat_cols).map(morph_color_dict)
measurement_color_map = pd.Series(measurement_labels, index=feat_cols).map(lambda x: measurement_color_dict.get(x, None))

# combine the two color maps
row_and_col_color_map = pd.DataFrame(
    {"Compartment": morph_color_map,
     "Measurement": measurement_color_map}
)

# generate seaborn clustermap with a larger figure size
clustermap = sns.clustermap(
    corr_morph_df.corr(method="pearson"),
    cmap="coolwarm",
    # row_colors=morph_color_map,
    # col_colors=morph_color_map,
    row_colors=row_and_col_color_map,
    col_colors=row_and_col_color_map,
    figsize=(12, 12),
    xticklabels=1,
    yticklabels=1,
)

# next remove the X and Y axis labels for better visualization and ticks
clustermap.ax_heatmap.set(xticklabels=[])
clustermap.ax_heatmap.set(yticklabels=[])
clustermap.ax_heatmap.set_xticks([])
clustermap.ax_heatmap.set_yticks([])

# Set the title of the clustermap
clustermap.fig.suptitle("Correlation cluster-heatmap of morphological features", x=0.37, y=1., fontsize=13)

# adding the Morphological features legend to the cluster map
handles = [mpatches.Patch(color=color, label=label) for label, color in morph_color_dict.items()]
clustermap.fig.legend(handles=handles, title="Compartment", loc="upper right", bbox_to_anchor=(.855, .75), fontsize=9)

# adding the Measurement type legend to the cluster map
handles = [mpatches.Patch(color=color, label=label) for label, color in measurement_color_dict.items()]
clustermap.fig.legend(handles=handles, title="Measurement", loc="upper right", bbox_to_anchor=(.87, .67), fontsize=9)

# move color gradient to the left side
clustermap.ax_heatmap.collections[0].colorbar.set_label("Correlation")
clustermap.cax.set_position([0.65, 0.39, 0.02, 0.4])


# save the clustermap to a file
clustermap.savefig(output_path / "clustermap_morph_features.png", dpi=500)
clustermap
